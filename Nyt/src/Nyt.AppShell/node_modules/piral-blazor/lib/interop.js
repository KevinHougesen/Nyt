import { emitRenderEvent, emitUpdateEvent, emitNavigateEvent, emitPiralEvent, blazorRootId } from './events';
const wasmLib = 'Microsoft.AspNetCore.Components.WebAssembly';
const coreLib = 'Piral.Blazor.Core';
function isDotNet6OrBelow() {
    return typeof window.Blazor?._internal?.NavigationLock === 'undefined';
}
function createBase() {
    // Nothing found, we need to guess
    const el = document.createElement('base');
    let baseUrl = el.href;
    // The main app is served by a script - but we don't know which one
    // hence we just iterate over all the local ones and use the script
    // that is served from the "shortest" route - should work almost
    // always and if not - one can always explicitely set a <base> node
    for (let i = document.scripts.length; i--;) {
        const s = document.scripts[i];
        const src = s.getAttribute('src');
        if (src && src.startsWith('/')) {
            const segEnd = src.lastIndexOf('/');
            const newUrl = src.substring(0, segEnd + 1);
            if (baseUrl.split('/').length > newUrl.split('/').length) {
                baseUrl = newUrl;
            }
        }
    }
    el.href = baseUrl;
    return document.head.appendChild(el);
}
async function prepareForStartup() {
    const originalApplyHotReload = window.Blazor._internal.applyHotReload;
    const queue = [];
    const applyChanges = (api) => {
        const pilet = api.meta;
        if (pilet.config && pilet.config.blazorHotReload) {
            for (const item of queue.splice(0, queue.length)) {
                item();
            }
            window.Blazor._internal.applyHotReload = originalApplyHotReload;
        }
    };
    window.Blazor._internal.applyHotReload = function (...args) {
        queue.push(() => originalApplyHotReload.apply(this, args));
    };
    const capabilities = await getCapabilities();
    if (capabilities.includes('custom-element')) {
        document.getElementById(blazorRootId).setAttribute('render', 'modern');
    }
    return {
        capabilities,
        applyChanges,
    };
}
function createBlazorStarter(publicPath) {
    const root = document.body.appendChild(document.createElement('div'));
    root.style.display = 'contents';
    root.id = blazorRootId;
    if (publicPath) {
        const baseElement = document.head.querySelector('base') || createBase();
        const originalBase = baseElement.href;
        baseElement.href = publicPath;
        return (opts) => {
            const navManager = window.Blazor._internal.navigationManager;
            //Overwrite to get NavigationManager in Blazor working, see https://github.com/smapiot/Piral.Blazor/issues/89
            navManager.navigateTo = (route, opts) => {
                if (opts.forceLoad) {
                    location.href = route;
                    return;
                }
                if (route.startsWith(location.origin) && '') {
                    // normalize "local" absolute URLs
                    route = route.substring(location.origin.length);
                }
                else if (/^https?:\/\//.test(route)) {
                    // prevent absolute URLs to be a standard navigation
                    location.href = route;
                    return;
                }
                window.Blazor.emitNavigateEvent(undefined, route, opts.replaceHistoryEntry, opts.historyEntryState);
            };
            navManager.getBaseURI = () => originalBase;
            return window.Blazor.start(opts)
                .then(prepareForStartup)
                .then(({ capabilities, applyChanges }) => {
                baseElement.href = originalBase;
                return [root, capabilities, applyChanges];
            });
        };
    }
    return (opts) => window.Blazor.start(opts)
        .then(prepareForStartup)
        .then(({ capabilities, applyChanges }) => [root, capabilities, applyChanges]);
}
function computePath() {
    try {
        throw new Error();
    }
    catch (t) {
        const e = ('' + t.stack).match(/(https?|file|ftp|chrome-extension|moz-extension):\/\/[^)\n]+/g);
        if (e) {
            return e[0].replace(/^((?:https?|file|ftp|chrome-extension|moz-extension):\/\/.+)\/[^\/]+$/, '$1') + '/';
        }
    }
    return '/';
}
function addScript(url) {
    return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = url;
        script.onerror = () => reject();
        script.onload = () => resolve();
        document.body.appendChild(script);
    });
}
function sanitize(props) {
    // children is a complex thing and will (in general) not be serializable
    // hence we need to make the JSObjectReference
    if ('children' in props && typeof props.children === 'object') {
        const { children, ...rest } = props;
        return {
            children: window.DotNet.createJSObjectReference(children),
            ...rest,
        };
    }
    return props;
}
export function processEvent(type, args) {
    return window.DotNet.invokeMethodAsync(coreLib, 'ProcessEvent', type, args);
}
export function setLogLevel(logLevel) {
    return window.DotNet.invokeMethodAsync(coreLib, 'SetLogLevel', logLevel);
}
export function createElement(moduleName, props) {
    return window.DotNet.invokeMethodAsync(coreLib, 'CreateElement', moduleName, sanitize(props));
}
export function updateElement(referenceId, props) {
    return window.DotNet.invokeMethodAsync(coreLib, 'UpdateElement', referenceId, sanitize(props));
}
export function destroyElement(referenceId) {
    return window.DotNet.invokeMethodAsync(coreLib, 'DestroyElement', referenceId);
}
export function activate(moduleName, props) {
    return window.DotNet.invokeMethodAsync(coreLib, 'Activate', moduleName, sanitize(props));
}
export function reactivate(moduleName, referenceId, props) {
    return window.DotNet.invokeMethodAsync(coreLib, 'Reactivate', moduleName, referenceId, sanitize(props)).catch(() => {
        // Apparently an older version of Piral.Blazor, which does not support this
        // discard this error silently (in the future we may print warnings here)
    });
}
export function deactivate(moduleName, referenceId) {
    return window.DotNet.invokeMethodAsync(coreLib, 'Deactivate', moduleName, referenceId);
}
export function callNotifyLocationChanged(url, replace, state) {
    if (isDotNet6OrBelow()) {
        return window.DotNet.invokeMethodAsync(wasmLib, 'NotifyLocationChanged', url, replace);
    }
    else {
        if (state !== undefined && typeof state !== 'string') {
            state = JSON.stringify(state);
        }
        return window.DotNet.invokeMethodAsync(wasmLib, 'NotifyLocationChanged', url, state, replace);
    }
}
export function setLanguage(language) {
    return window.DotNet.invokeMethodAsync(coreLib, 'SetLanguage', language);
}
export function getCapabilities() {
    return window.DotNet.invokeMethodAsync(coreLib, 'GetCapabilities').catch(() => {
        // Apparently an older version of Piral.Blazor, which does not support this
        // discard this error silently (in the future we may print warnings here)
        return [];
    });
}
export function loadResource(url) {
    return window.DotNet.invokeMethodAsync(coreLib, 'LoadComponentsFromLibrary', url);
}
export function loadResourceWithSymbol(dllUrl, pdbUrl) {
    return window.DotNet.invokeMethodAsync(coreLib, 'LoadComponentsWithSymbolsFromLibrary', dllUrl, pdbUrl);
}
export function unloadResource(url) {
    return window.DotNet.invokeMethodAsync(coreLib, 'UnloadComponentsFromLibrary', url);
}
export function loadBlazorPilet(id, data) {
    return window.DotNet.invokeMethodAsync(coreLib, 'LoadPilet', id, data);
}
export function unloadBlazorPilet(id) {
    return window.DotNet.invokeMethodAsync(coreLib, 'UnloadPilet', id);
}
export function initialize(scriptUrl, publicPath, opts = {}) {
    if (typeof opts.loadBootResource !== 'function') {
        opts.loadBootResource = (type, name, url) => type === 'dotnetjs' ? url : fetch(url, { method: 'GET', cache: 'no-cache' });
    }
    return new Promise((resolve, reject) => {
        const startBlazor = createBlazorStarter(publicPath);
        const script = document.createElement('script');
        script.src = scriptUrl;
        script.setAttribute('autostart', 'false');
        script.onerror = () => reject();
        script.onload = () => {
            Object.assign(window.Blazor, {
                emitRenderEvent,
                emitUpdateEvent,
                emitNavigateEvent,
                emitPiralEvent,
            });
            startBlazor(opts).then(resolve);
        };
        document.body.appendChild(script);
    });
}
export function createBootLoader(scriptUrl, extraScriptUrls) {
    const publicPath = computePath();
    return async (opts) => {
        const first = typeof window.$blazorLoader === 'undefined';
        if (first) {
            window.dispatchEvent(new CustomEvent('loading-blazor-core'));
            // we load all satellite scripts before we initialize blazor
            window.$blazorLoader = Promise.all(extraScriptUrls.map(addScript)).then(() => initialize(scriptUrl, publicPath, opts));
        }
        const config = await window.$blazorLoader;
        return {
            config,
            first,
        };
    };
}
//# sourceMappingURL=interop.js.map